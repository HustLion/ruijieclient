/* RC_DBus_Interface.c generated by valac, the Vala compiler
 * generated from RC_DBus_Interface.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus.h>


#define TYPE_RUIJIE_DBUS_SERVER_INTERFACE (ruijie_dbus_server_interface_get_type ())
#define RUIJIE_DBUS_SERVER_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RUIJIE_DBUS_SERVER_INTERFACE, RuijieDbusServerInterface))
#define IS_RUIJIE_DBUS_SERVER_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RUIJIE_DBUS_SERVER_INTERFACE))
#define RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_RUIJIE_DBUS_SERVER_INTERFACE, RuijieDbusServerInterfaceIface))

typedef struct _RuijieDbusServerInterface RuijieDbusServerInterface;
typedef struct _RuijieDbusServerInterfaceIface RuijieDbusServerInterfaceIface;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _RuijieDbusServerInterfaceDBusProxy RuijieDbusServerInterfaceDBusProxy;
typedef DBusGProxyClass RuijieDbusServerInterfaceDBusProxyClass;
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _RuijieDbusServerInterfaceIface {
	GTypeInterface parent_iface;
	gint32 (*Auth) (RuijieDbusServerInterface* self, GError** error);
	gint32 (*DisAuth) (RuijieDbusServerInterface* self, GError** error);
	gint32 (*SetPassword) (RuijieDbusServerInterface* self, const char* passwd, GError** error);
	gint32 (*get_State) (RuijieDbusServerInterface* self);
	void (*set_State) (RuijieDbusServerInterface* self, gint32 value);
	char* (*get_Message) (RuijieDbusServerInterface* self);
	void (*set_Message) (RuijieDbusServerInterface* self, const char* value);
	char* (*get_NetInterface) (RuijieDbusServerInterface* self);
	void (*set_NetInterface) (RuijieDbusServerInterface* self, const char* value);
	char* (*get_UserName) (RuijieDbusServerInterface* self);
	void (*set_UserName) (RuijieDbusServerInterface* self, const char* value);
	gint32 (*get_AuthenticationMode) (RuijieDbusServerInterface* self);
	void (*set_AuthenticationMode) (RuijieDbusServerInterface* self, gint32 value);
	gint32 (*get_EchoInterval) (RuijieDbusServerInterface* self);
	void (*set_EchoInterval) (RuijieDbusServerInterface* self, gint32 value);
	gboolean (*get_IntelligentReconnect) (RuijieDbusServerInterface* self);
	void (*set_IntelligentReconnect) (RuijieDbusServerInterface* self, gboolean value);
	gboolean (*get_AutoConnect) (RuijieDbusServerInterface* self);
	void (*set_AutoConnect) (RuijieDbusServerInterface* self, gboolean value);
	char* (*get_FakeVersion) (RuijieDbusServerInterface* self);
	void (*set_FakeVersion) (RuijieDbusServerInterface* self, const char* value);
	gint32 (*get_DHCPmode) (RuijieDbusServerInterface* self);
	void (*set_DHCPmode) (RuijieDbusServerInterface* self, gint32 value);
	char* (*get_PingHost) (RuijieDbusServerInterface* self);
	void (*set_PingHost) (RuijieDbusServerInterface* self, const char* value);
};

struct _RuijieDbusServerInterfaceDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};



GType ruijie_dbus_server_interface_get_type (void);
gint32 ruijie_dbus_server_interface_Auth (RuijieDbusServerInterface* self, GError** error);
gint32 ruijie_dbus_server_interface_DisAuth (RuijieDbusServerInterface* self, GError** error);
gint32 ruijie_dbus_server_interface_SetPassword (RuijieDbusServerInterface* self, const char* passwd, GError** error);
gint32 ruijie_dbus_server_interface_get_State (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_State (RuijieDbusServerInterface* self, gint32 value);
char* ruijie_dbus_server_interface_get_Message (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_Message (RuijieDbusServerInterface* self, const char* value);
char* ruijie_dbus_server_interface_get_NetInterface (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_set_NetInterface (RuijieDbusServerInterface* self, const char* value);
char* ruijie_dbus_server_interface_get_UserName (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_UserName (RuijieDbusServerInterface* self, const char* value);
gint32 ruijie_dbus_server_interface_get_AuthenticationMode (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_AuthenticationMode (RuijieDbusServerInterface* self, gint32 value);
gint32 ruijie_dbus_server_interface_get_EchoInterval (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_EchoInterval (RuijieDbusServerInterface* self, gint32 value);
gboolean ruijie_dbus_server_interface_get_IntelligentReconnect (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_IntelligentReconnect (RuijieDbusServerInterface* self, gboolean value);
gboolean ruijie_dbus_server_interface_get_AutoConnect (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_AutoConnect (RuijieDbusServerInterface* self, gboolean value);
char* ruijie_dbus_server_interface_get_FakeVersion (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_FakeVersion (RuijieDbusServerInterface* self, const char* value);
gint32 ruijie_dbus_server_interface_get_DHCPmode (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_DHCPmode (RuijieDbusServerInterface* self, gint32 value);
char* ruijie_dbus_server_interface_get_PingHost (RuijieDbusServerInterface* self);
void ruijie_dbus_server_interface_set_PingHost (RuijieDbusServerInterface* self, const char* value);
void ruijie_dbus_server_interface_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _ruijie_dbus_server_interface_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult ruijie_dbus_server_interface_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_introspect (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_get (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_set (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_get_all (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_Auth (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_DisAuth (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_ruijie_dbus_server_interface_SetPassword (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_ruijie_dbus_server_interface_state_changed (GObject* _sender, DBusConnection* _connection);
GType ruijie_dbus_server_interface_dbus_proxy_get_type (void);
RuijieDbusServerInterface* ruijie_dbus_server_interface_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
static void _dbus_handle_ruijie_dbus_server_interface_state_changed (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult ruijie_dbus_server_interface_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_DUMMY_PROPERTY,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_STATE,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_MESSAGE,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_NET_INTERFACE,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_USER_NAME,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_AUTHENTICATION_MODE,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_ECHO_INTERVAL,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_INTELLIGENT_RECONNECT,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_AUTO_CONNECT,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_FAKE_VERSION,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_DHC_PMODE,
	RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_PING_HOST
};
static gint32 ruijie_dbus_server_interface_dbus_proxy_Auth (RuijieDbusServerInterface* self, GError** error);
static gint32 ruijie_dbus_server_interface_dbus_proxy_DisAuth (RuijieDbusServerInterface* self, GError** error);
static gint32 ruijie_dbus_server_interface_dbus_proxy_SetPassword (RuijieDbusServerInterface* self, const char* passwd, GError** error);
static gint32 ruijie_dbus_server_interface_dbus_proxy_get_State (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_State (RuijieDbusServerInterface* self, gint32 value);
static char* ruijie_dbus_server_interface_dbus_proxy_get_Message (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_Message (RuijieDbusServerInterface* self, const char* value);
static char* ruijie_dbus_server_interface_dbus_proxy_get_NetInterface (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_NetInterface (RuijieDbusServerInterface* self, const char* value);
static char* ruijie_dbus_server_interface_dbus_proxy_get_UserName (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_UserName (RuijieDbusServerInterface* self, const char* value);
static gint32 ruijie_dbus_server_interface_dbus_proxy_get_AuthenticationMode (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_AuthenticationMode (RuijieDbusServerInterface* self, gint32 value);
static gint32 ruijie_dbus_server_interface_dbus_proxy_get_EchoInterval (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_EchoInterval (RuijieDbusServerInterface* self, gint32 value);
static gboolean ruijie_dbus_server_interface_dbus_proxy_get_IntelligentReconnect (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_IntelligentReconnect (RuijieDbusServerInterface* self, gboolean value);
static gboolean ruijie_dbus_server_interface_dbus_proxy_get_AutoConnect (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_AutoConnect (RuijieDbusServerInterface* self, gboolean value);
static char* ruijie_dbus_server_interface_dbus_proxy_get_FakeVersion (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_FakeVersion (RuijieDbusServerInterface* self, const char* value);
static gint32 ruijie_dbus_server_interface_dbus_proxy_get_DHCPmode (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_DHCPmode (RuijieDbusServerInterface* self, gint32 value);
static char* ruijie_dbus_server_interface_dbus_proxy_get_PingHost (RuijieDbusServerInterface* self);
static void ruijie_dbus_server_interface_dbus_proxy_set_PingHost (RuijieDbusServerInterface* self, const char* value);
static void ruijie_dbus_server_interface_dbus_proxy_ruijie_dbus_server_interface__interface_init (RuijieDbusServerInterfaceIface* iface);
static void ruijie_dbus_server_interface_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void ruijie_dbus_server_interface_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);

static const DBusObjectPathVTable _ruijie_dbus_server_interface_dbus_path_vtable = {_ruijie_dbus_server_interface_dbus_unregister, ruijie_dbus_server_interface_dbus_message};
static const _DBusObjectVTable _ruijie_dbus_server_interface_dbus_vtable = {ruijie_dbus_server_interface_dbus_register_object};


gint32 ruijie_dbus_server_interface_Auth (RuijieDbusServerInterface* self, GError** error) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->Auth (self, error);
}


gint32 ruijie_dbus_server_interface_DisAuth (RuijieDbusServerInterface* self, GError** error) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->DisAuth (self, error);
}


gint32 ruijie_dbus_server_interface_SetPassword (RuijieDbusServerInterface* self, const char* passwd, GError** error) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->SetPassword (self, passwd, error);
}


gint32 ruijie_dbus_server_interface_get_State (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_State (self);
}


void ruijie_dbus_server_interface_set_State (RuijieDbusServerInterface* self, gint32 value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_State (self, value);
}


char* ruijie_dbus_server_interface_get_Message (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_Message (self);
}


void ruijie_dbus_server_interface_set_Message (RuijieDbusServerInterface* self, const char* value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_Message (self, value);
}


char* ruijie_dbus_server_interface_get_NetInterface (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_NetInterface (self);
}


static void ruijie_dbus_server_interface_set_NetInterface (RuijieDbusServerInterface* self, const char* value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_NetInterface (self, value);
}


char* ruijie_dbus_server_interface_get_UserName (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_UserName (self);
}


void ruijie_dbus_server_interface_set_UserName (RuijieDbusServerInterface* self, const char* value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_UserName (self, value);
}


gint32 ruijie_dbus_server_interface_get_AuthenticationMode (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_AuthenticationMode (self);
}


void ruijie_dbus_server_interface_set_AuthenticationMode (RuijieDbusServerInterface* self, gint32 value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_AuthenticationMode (self, value);
}


gint32 ruijie_dbus_server_interface_get_EchoInterval (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_EchoInterval (self);
}


void ruijie_dbus_server_interface_set_EchoInterval (RuijieDbusServerInterface* self, gint32 value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_EchoInterval (self, value);
}


gboolean ruijie_dbus_server_interface_get_IntelligentReconnect (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_IntelligentReconnect (self);
}


void ruijie_dbus_server_interface_set_IntelligentReconnect (RuijieDbusServerInterface* self, gboolean value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_IntelligentReconnect (self, value);
}


gboolean ruijie_dbus_server_interface_get_AutoConnect (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_AutoConnect (self);
}


void ruijie_dbus_server_interface_set_AutoConnect (RuijieDbusServerInterface* self, gboolean value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_AutoConnect (self, value);
}


char* ruijie_dbus_server_interface_get_FakeVersion (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_FakeVersion (self);
}


void ruijie_dbus_server_interface_set_FakeVersion (RuijieDbusServerInterface* self, const char* value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_FakeVersion (self, value);
}


gint32 ruijie_dbus_server_interface_get_DHCPmode (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_DHCPmode (self);
}


void ruijie_dbus_server_interface_set_DHCPmode (RuijieDbusServerInterface* self, gint32 value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_DHCPmode (self, value);
}


char* ruijie_dbus_server_interface_get_PingHost (RuijieDbusServerInterface* self) {
	return RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->get_PingHost (self);
}


void ruijie_dbus_server_interface_set_PingHost (RuijieDbusServerInterface* self, const char* value) {
	RUIJIE_DBUS_SERVER_INTERFACE_GET_INTERFACE (self)->set_PingHost (self, value);
}


void _ruijie_dbus_server_interface_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_introspect (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.googlecode.ruijieclient\">\n  <method name=\"Auth\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"DisAuth\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"SetPassword\">\n    <arg name=\"passwd\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <property name=\"State\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"Message\" type=\"s\" access=\"readwrite\"/>\n  <property name=\"NetInterface\" type=\"s\" access=\"readwrite\"/>\n  <property name=\"UserName\" type=\"s\" access=\"readwrite\"/>\n  <property name=\"AuthenticationMode\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"EchoInterval\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"IntelligentReconnect\" type=\"b\" access=\"readwrite\"/>\n  <property name=\"AutoConnect\" type=\"b\" access=\"readwrite\"/>\n  <property name=\"FakeVersion\" type=\"s\" access=\"readwrite\"/>\n  <property name=\"DHCPmode\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PingHost\" type=\"s\" access=\"readwrite\"/>\n  <signal name=\"StateChanged\">\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_get (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	char* property_name;
	const char* _tmp1_;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	dbus_message_iter_get_basic (&iter, &_tmp1_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp1_);
	if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "State") == 0)) {
		gint32 result;
		dbus_int32_t _tmp2_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
		result = ruijie_dbus_server_interface_get_State (self);
		_tmp2_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_INT32, &_tmp2_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "Message") == 0)) {
		char* result;
		const char* _tmp3_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = ruijie_dbus_server_interface_get_Message (self);
		_tmp3_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp3_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "NetInterface") == 0)) {
		char* result;
		const char* _tmp4_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = ruijie_dbus_server_interface_get_NetInterface (self);
		_tmp4_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp4_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "UserName") == 0)) {
		char* result;
		const char* _tmp5_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = ruijie_dbus_server_interface_get_UserName (self);
		_tmp5_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp5_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "AuthenticationMode") == 0)) {
		gint32 result;
		dbus_int32_t _tmp6_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
		result = ruijie_dbus_server_interface_get_AuthenticationMode (self);
		_tmp6_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_INT32, &_tmp6_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "EchoInterval") == 0)) {
		gint32 result;
		dbus_int32_t _tmp7_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
		result = ruijie_dbus_server_interface_get_EchoInterval (self);
		_tmp7_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_INT32, &_tmp7_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "IntelligentReconnect") == 0)) {
		gboolean result;
		dbus_bool_t _tmp8_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "b", &subiter);
		result = ruijie_dbus_server_interface_get_IntelligentReconnect (self);
		_tmp8_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_BOOLEAN, &_tmp8_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "AutoConnect") == 0)) {
		gboolean result;
		dbus_bool_t _tmp9_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "b", &subiter);
		result = ruijie_dbus_server_interface_get_AutoConnect (self);
		_tmp9_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_BOOLEAN, &_tmp9_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "FakeVersion") == 0)) {
		char* result;
		const char* _tmp10_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = ruijie_dbus_server_interface_get_FakeVersion (self);
		_tmp10_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp10_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "DHCPmode") == 0)) {
		gint32 result;
		dbus_int32_t _tmp11_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
		result = ruijie_dbus_server_interface_get_DHCPmode (self);
		_tmp11_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_INT32, &_tmp11_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "PingHost") == 0)) {
		char* result;
		const char* _tmp12_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = ruijie_dbus_server_interface_get_PingHost (self);
		_tmp12_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp12_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_set (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, subiter;
	char* interface_name;
	const char* _tmp13_;
	char* property_name;
	const char* _tmp14_;
	if (strcmp (dbus_message_get_signature (message), "ssv")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_get_basic (&iter, &_tmp13_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp13_);
	dbus_message_iter_get_basic (&iter, &_tmp14_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp14_);
	dbus_message_iter_recurse (&iter, &subiter);
	if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "State") == 0)) {
		gint32 value;
		dbus_int32_t _tmp15_;
		dbus_message_iter_get_basic (&subiter, &_tmp15_);
		dbus_message_iter_next (&subiter);
		value = _tmp15_;
		ruijie_dbus_server_interface_set_State (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "Message") == 0)) {
		char* value;
		const char* _tmp16_;
		dbus_message_iter_get_basic (&subiter, &_tmp16_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp16_);
		ruijie_dbus_server_interface_set_Message (self, value);
		_g_free0 (value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "NetInterface") == 0)) {
		char* value;
		const char* _tmp17_;
		dbus_message_iter_get_basic (&subiter, &_tmp17_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp17_);
		ruijie_dbus_server_interface_set_NetInterface (self, value);
		_g_free0 (value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "UserName") == 0)) {
		char* value;
		const char* _tmp18_;
		dbus_message_iter_get_basic (&subiter, &_tmp18_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp18_);
		ruijie_dbus_server_interface_set_UserName (self, value);
		_g_free0 (value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "AuthenticationMode") == 0)) {
		gint32 value;
		dbus_int32_t _tmp19_;
		dbus_message_iter_get_basic (&subiter, &_tmp19_);
		dbus_message_iter_next (&subiter);
		value = _tmp19_;
		ruijie_dbus_server_interface_set_AuthenticationMode (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "EchoInterval") == 0)) {
		gint32 value;
		dbus_int32_t _tmp20_;
		dbus_message_iter_get_basic (&subiter, &_tmp20_);
		dbus_message_iter_next (&subiter);
		value = _tmp20_;
		ruijie_dbus_server_interface_set_EchoInterval (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "IntelligentReconnect") == 0)) {
		gboolean value;
		dbus_bool_t _tmp21_;
		dbus_message_iter_get_basic (&subiter, &_tmp21_);
		dbus_message_iter_next (&subiter);
		value = _tmp21_;
		ruijie_dbus_server_interface_set_IntelligentReconnect (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "AutoConnect") == 0)) {
		gboolean value;
		dbus_bool_t _tmp22_;
		dbus_message_iter_get_basic (&subiter, &_tmp22_);
		dbus_message_iter_next (&subiter);
		value = _tmp22_;
		ruijie_dbus_server_interface_set_AutoConnect (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "FakeVersion") == 0)) {
		char* value;
		const char* _tmp23_;
		dbus_message_iter_get_basic (&subiter, &_tmp23_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp23_);
		ruijie_dbus_server_interface_set_FakeVersion (self, value);
		_g_free0 (value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "DHCPmode") == 0)) {
		gint32 value;
		dbus_int32_t _tmp24_;
		dbus_message_iter_get_basic (&subiter, &_tmp24_);
		dbus_message_iter_next (&subiter);
		value = _tmp24_;
		ruijie_dbus_server_interface_set_DHCPmode (self, value);
	} else if ((strcmp (interface_name, "com.googlecode.ruijieclient") == 0) && (strcmp (property_name, "PingHost") == 0)) {
		char* value;
		const char* _tmp25_;
		dbus_message_iter_get_basic (&subiter, &_tmp25_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp25_);
		ruijie_dbus_server_interface_set_PingHost (self, value);
		_g_free0 (value);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_property_get_all (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter, entry_iter, value_iter;
	char* interface_name;
	const char* _tmp26_;
	const char* property_name;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp26_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp26_);
	if (strcmp (interface_name, "com.googlecode.ruijieclient") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		{
			gint32 result;
			dbus_int32_t _tmp27_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "State";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
			result = ruijie_dbus_server_interface_get_State (self);
			_tmp27_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_INT32, &_tmp27_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp28_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "Message";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = ruijie_dbus_server_interface_get_Message (self);
			_tmp28_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp28_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp29_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "NetInterface";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = ruijie_dbus_server_interface_get_NetInterface (self);
			_tmp29_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp29_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp30_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "UserName";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = ruijie_dbus_server_interface_get_UserName (self);
			_tmp30_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp30_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gint32 result;
			dbus_int32_t _tmp31_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "AuthenticationMode";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
			result = ruijie_dbus_server_interface_get_AuthenticationMode (self);
			_tmp31_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_INT32, &_tmp31_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gint32 result;
			dbus_int32_t _tmp32_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "EchoInterval";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
			result = ruijie_dbus_server_interface_get_EchoInterval (self);
			_tmp32_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_INT32, &_tmp32_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gboolean result;
			dbus_bool_t _tmp33_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "IntelligentReconnect";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "b", &value_iter);
			result = ruijie_dbus_server_interface_get_IntelligentReconnect (self);
			_tmp33_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_BOOLEAN, &_tmp33_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gboolean result;
			dbus_bool_t _tmp34_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "AutoConnect";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "b", &value_iter);
			result = ruijie_dbus_server_interface_get_AutoConnect (self);
			_tmp34_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_BOOLEAN, &_tmp34_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp35_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "FakeVersion";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = ruijie_dbus_server_interface_get_FakeVersion (self);
			_tmp35_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp35_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gint32 result;
			dbus_int32_t _tmp36_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "DHCPmode";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
			result = ruijie_dbus_server_interface_get_DHCPmode (self);
			_tmp36_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_INT32, &_tmp36_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp37_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "PingHost";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = ruijie_dbus_server_interface_get_PingHost (self);
			_tmp37_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp37_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_Auth (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint32 result;
	DBusMessage* reply;
	dbus_int32_t _tmp38_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = ruijie_dbus_server_interface_Auth (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp38_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp38_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_DisAuth (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint32 result;
	DBusMessage* reply;
	dbus_int32_t _tmp39_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = ruijie_dbus_server_interface_DisAuth (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp39_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp39_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_ruijie_dbus_server_interface_SetPassword (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* passwd = NULL;
	const char* _tmp40_;
	gint32 result;
	DBusMessage* reply;
	dbus_int32_t _tmp41_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp40_);
	dbus_message_iter_next (&iter);
	passwd = g_strdup (_tmp40_);
	result = ruijie_dbus_server_interface_SetPassword (self, passwd, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (passwd);
	_tmp41_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp41_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult ruijie_dbus_server_interface_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_ruijie_dbus_server_interface_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Get")) {
		result = _dbus_ruijie_dbus_server_interface_property_get (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Set")) {
		result = _dbus_ruijie_dbus_server_interface_property_set (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_ruijie_dbus_server_interface_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.googlecode.ruijieclient", "Auth")) {
		result = _dbus_ruijie_dbus_server_interface_Auth (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.googlecode.ruijieclient", "DisAuth")) {
		result = _dbus_ruijie_dbus_server_interface_DisAuth (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.googlecode.ruijieclient", "SetPassword")) {
		result = _dbus_ruijie_dbus_server_interface_SetPassword (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_ruijie_dbus_server_interface_state_changed (GObject* _sender, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.googlecode.ruijieclient", "StateChanged");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void ruijie_dbus_server_interface_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_ruijie_dbus_server_interface_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "state-changed", (GCallback) _dbus_ruijie_dbus_server_interface_state_changed, connection);
}


static void ruijie_dbus_server_interface_base_init (RuijieDbusServerInterfaceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("state_changed", TYPE_RUIJIE_DBUS_SERVER_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
		g_type_set_qdata (TYPE_RUIJIE_DBUS_SERVER_INTERFACE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_ruijie_dbus_server_interface_dbus_vtable));
	}
}


GType ruijie_dbus_server_interface_get_type (void) {
	static GType ruijie_dbus_server_interface_type_id = 0;
	if (ruijie_dbus_server_interface_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (RuijieDbusServerInterfaceIface), (GBaseInitFunc) ruijie_dbus_server_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		ruijie_dbus_server_interface_type_id = g_type_register_static (G_TYPE_INTERFACE, "RuijieDbusServerInterface", &g_define_type_info, 0);
		g_type_set_qdata (ruijie_dbus_server_interface_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &ruijie_dbus_server_interface_dbus_proxy_get_type);
	}
	return ruijie_dbus_server_interface_type_id;
}


G_DEFINE_TYPE_EXTENDED (RuijieDbusServerInterfaceDBusProxy, ruijie_dbus_server_interface_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_RUIJIE_DBUS_SERVER_INTERFACE, ruijie_dbus_server_interface_dbus_proxy_ruijie_dbus_server_interface__interface_init) );
RuijieDbusServerInterface* ruijie_dbus_server_interface_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	RuijieDbusServerInterface* self;
	self = g_object_new (ruijie_dbus_server_interface_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "com.googlecode.ruijieclient", NULL);
	return self;
}


static GObject* ruijie_dbus_server_interface_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (ruijie_dbus_server_interface_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), ruijie_dbus_server_interface_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_ruijie_dbus_server_interface_state_changed (RuijieDbusServerInterface* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	g_signal_emit_by_name (self, "state-changed");
}


DBusHandlerResult ruijie_dbus_server_interface_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "com.googlecode.ruijieclient", "StateChanged")) {
			_dbus_handle_ruijie_dbus_server_interface_state_changed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void ruijie_dbus_server_interface_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	((RuijieDbusServerInterfaceDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), ruijie_dbus_server_interface_dbus_proxy_filter, self);
	G_OBJECT_CLASS (ruijie_dbus_server_interface_dbus_proxy_parent_class)->dispose (self);
}


static void ruijie_dbus_server_interface_dbus_proxy_class_init (RuijieDbusServerInterfaceDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = ruijie_dbus_server_interface_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = ruijie_dbus_server_interface_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = ruijie_dbus_server_interface_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = ruijie_dbus_server_interface_dbus_proxy_set_property;
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_STATE, "State");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_MESSAGE, "Message");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_NET_INTERFACE, "NetInterface");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_USER_NAME, "UserName");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_AUTHENTICATION_MODE, "AuthenticationMode");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_ECHO_INTERVAL, "EchoInterval");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_INTELLIGENT_RECONNECT, "IntelligentReconnect");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_AUTO_CONNECT, "AutoConnect");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_FAKE_VERSION, "FakeVersion");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_DHC_PMODE, "DHCPmode");
	g_object_class_override_property (G_OBJECT_CLASS (klass), RUIJIE_DBUS_SERVER_INTERFACE_DBUS_PROXY_PING_HOST, "PingHost");
}


static void ruijie_dbus_server_interface_dbus_proxy_init (RuijieDbusServerInterfaceDBusProxy* self) {
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_Auth (RuijieDbusServerInterface* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	gint32 _result;
	dbus_int32_t _tmp42_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		g_set_error_literal (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "Connection is closed");
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.googlecode.ruijieclient", "Auth");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp43_;
			_edomain = DBUS_GERROR;
			_tmp43_ = _dbus_error.name + 27;
			if (strcmp (_tmp43_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp43_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp43_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp43_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp43_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp43_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp43_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp43_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp43_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp43_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp43_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp43_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp43_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp43_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp43_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp43_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp43_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp43_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp43_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp43_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp43_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp43_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp43_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp43_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp43_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp43_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp43_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp43_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp43_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp43_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp43_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp43_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp43_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error_literal (error, _edomain, _ecode, _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return 0;
	}
	if (strcmp (dbus_message_get_signature (_reply), "i")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "i", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_get_basic (&_iter, &_tmp42_);
	dbus_message_iter_next (&_iter);
	_result = _tmp42_;
	dbus_message_unref (_reply);
	return _result;
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_DisAuth (RuijieDbusServerInterface* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	gint32 _result;
	dbus_int32_t _tmp44_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		g_set_error_literal (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "Connection is closed");
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.googlecode.ruijieclient", "DisAuth");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp45_;
			_edomain = DBUS_GERROR;
			_tmp45_ = _dbus_error.name + 27;
			if (strcmp (_tmp45_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp45_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp45_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp45_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp45_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp45_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp45_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp45_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp45_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp45_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp45_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp45_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp45_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp45_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp45_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp45_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp45_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp45_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp45_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp45_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp45_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp45_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp45_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp45_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp45_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp45_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp45_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp45_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp45_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp45_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp45_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp45_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp45_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error_literal (error, _edomain, _ecode, _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return 0;
	}
	if (strcmp (dbus_message_get_signature (_reply), "i")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "i", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_get_basic (&_iter, &_tmp44_);
	dbus_message_iter_next (&_iter);
	_result = _tmp44_;
	dbus_message_unref (_reply);
	return _result;
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_SetPassword (RuijieDbusServerInterface* self, const char* passwd, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp46_;
	gint32 _result;
	dbus_int32_t _tmp47_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		g_set_error_literal (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "Connection is closed");
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "com.googlecode.ruijieclient", "SetPassword");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp46_ = passwd;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp46_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp48_;
			_edomain = DBUS_GERROR;
			_tmp48_ = _dbus_error.name + 27;
			if (strcmp (_tmp48_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp48_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp48_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp48_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp48_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp48_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp48_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp48_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp48_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp48_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp48_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp48_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp48_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp48_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp48_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp48_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp48_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp48_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp48_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp48_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp48_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp48_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp48_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp48_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp48_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp48_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp48_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp48_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp48_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp48_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp48_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp48_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp48_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error_literal (error, _edomain, _ecode, _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return 0;
	}
	if (strcmp (dbus_message_get_signature (_reply), "i")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "i", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_get_basic (&_iter, &_tmp47_);
	dbus_message_iter_next (&_iter);
	_result = _tmp47_;
	dbus_message_unref (_reply);
	return _result;
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_get_State (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp49_;
	const char* _tmp50_;
	gint32 _result;
	dbus_int32_t _tmp51_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp49_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp49_);
	_tmp50_ = "State";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp50_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp51_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp51_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_State (RuijieDbusServerInterface* self, gint32 value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp52_;
	const char* _tmp53_;
	dbus_int32_t _tmp54_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp52_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp52_);
	_tmp53_ = "State";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp53_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "i", &_subiter);
	_tmp54_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_INT32, &_tmp54_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* ruijie_dbus_server_interface_dbus_proxy_get_Message (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp55_;
	const char* _tmp56_;
	char* _result;
	const char* _tmp57_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp55_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp55_);
	_tmp56_ = "Message";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp56_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp57_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp57_);
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_Message (RuijieDbusServerInterface* self, const char* value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp58_;
	const char* _tmp59_;
	const char* _tmp60_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp58_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp58_);
	_tmp59_ = "Message";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp59_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp60_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp60_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* ruijie_dbus_server_interface_dbus_proxy_get_NetInterface (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp61_;
	const char* _tmp62_;
	char* _result;
	const char* _tmp63_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp61_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp61_);
	_tmp62_ = "NetInterface";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp62_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp63_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp63_);
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_NetInterface (RuijieDbusServerInterface* self, const char* value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp64_;
	const char* _tmp65_;
	const char* _tmp66_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp64_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp64_);
	_tmp65_ = "NetInterface";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp65_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp66_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp66_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* ruijie_dbus_server_interface_dbus_proxy_get_UserName (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp67_;
	const char* _tmp68_;
	char* _result;
	const char* _tmp69_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp67_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp67_);
	_tmp68_ = "UserName";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp68_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp69_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp69_);
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_UserName (RuijieDbusServerInterface* self, const char* value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp70_;
	const char* _tmp71_;
	const char* _tmp72_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp70_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp70_);
	_tmp71_ = "UserName";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp71_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp72_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp72_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_get_AuthenticationMode (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp73_;
	const char* _tmp74_;
	gint32 _result;
	dbus_int32_t _tmp75_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp73_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp73_);
	_tmp74_ = "AuthenticationMode";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp74_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp75_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp75_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_AuthenticationMode (RuijieDbusServerInterface* self, gint32 value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp76_;
	const char* _tmp77_;
	dbus_int32_t _tmp78_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp76_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp76_);
	_tmp77_ = "AuthenticationMode";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp77_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "i", &_subiter);
	_tmp78_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_INT32, &_tmp78_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_get_EchoInterval (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp79_;
	const char* _tmp80_;
	gint32 _result;
	dbus_int32_t _tmp81_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp79_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp79_);
	_tmp80_ = "EchoInterval";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp80_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp81_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp81_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_EchoInterval (RuijieDbusServerInterface* self, gint32 value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp82_;
	const char* _tmp83_;
	dbus_int32_t _tmp84_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp82_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp82_);
	_tmp83_ = "EchoInterval";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp83_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "i", &_subiter);
	_tmp84_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_INT32, &_tmp84_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gboolean ruijie_dbus_server_interface_dbus_proxy_get_IntelligentReconnect (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp85_;
	const char* _tmp86_;
	gboolean _result;
	dbus_bool_t _tmp87_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return FALSE;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp85_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp85_);
	_tmp86_ = "IntelligentReconnect";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp86_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp87_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp87_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_IntelligentReconnect (RuijieDbusServerInterface* self, gboolean value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp88_;
	const char* _tmp89_;
	dbus_bool_t _tmp90_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp88_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp88_);
	_tmp89_ = "IntelligentReconnect";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp89_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "b", &_subiter);
	_tmp90_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_BOOLEAN, &_tmp90_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gboolean ruijie_dbus_server_interface_dbus_proxy_get_AutoConnect (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp91_;
	const char* _tmp92_;
	gboolean _result;
	dbus_bool_t _tmp93_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return FALSE;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp91_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp91_);
	_tmp92_ = "AutoConnect";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp92_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp93_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp93_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_AutoConnect (RuijieDbusServerInterface* self, gboolean value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp94_;
	const char* _tmp95_;
	dbus_bool_t _tmp96_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp94_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp94_);
	_tmp95_ = "AutoConnect";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp95_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "b", &_subiter);
	_tmp96_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_BOOLEAN, &_tmp96_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* ruijie_dbus_server_interface_dbus_proxy_get_FakeVersion (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp97_;
	const char* _tmp98_;
	char* _result;
	const char* _tmp99_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp97_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp97_);
	_tmp98_ = "FakeVersion";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp98_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp99_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp99_);
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_FakeVersion (RuijieDbusServerInterface* self, const char* value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp100_;
	const char* _tmp101_;
	const char* _tmp102_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp100_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp100_);
	_tmp101_ = "FakeVersion";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp101_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp102_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp102_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gint32 ruijie_dbus_server_interface_dbus_proxy_get_DHCPmode (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp103_;
	const char* _tmp104_;
	gint32 _result;
	dbus_int32_t _tmp105_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp103_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp103_);
	_tmp104_ = "DHCPmode";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp104_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp105_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp105_;
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_DHCPmode (RuijieDbusServerInterface* self, gint32 value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp106_;
	const char* _tmp107_;
	dbus_int32_t _tmp108_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp106_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp106_);
	_tmp107_ = "DHCPmode";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp107_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "i", &_subiter);
	_tmp108_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_INT32, &_tmp108_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* ruijie_dbus_server_interface_dbus_proxy_get_PingHost (RuijieDbusServerInterface* self) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp109_;
	const char* _tmp110_;
	char* _result;
	const char* _tmp111_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp109_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp109_);
	_tmp110_ = "PingHost";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp110_);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	dbus_message_iter_get_basic (&_subiter, &_tmp111_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp111_);
	dbus_message_unref (_reply);
	return _result;
}


static void ruijie_dbus_server_interface_dbus_proxy_set_PingHost (RuijieDbusServerInterface* self, const char* value) {
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp112_;
	const char* _tmp113_;
	const char* _tmp114_;
	if (((RuijieDbusServerInterfaceDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp112_ = "com.googlecode.ruijieclient";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp112_);
	_tmp113_ = "PingHost";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp113_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp114_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp114_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, NULL);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void ruijie_dbus_server_interface_dbus_proxy_ruijie_dbus_server_interface__interface_init (RuijieDbusServerInterfaceIface* iface) {
	iface->Auth = ruijie_dbus_server_interface_dbus_proxy_Auth;
	iface->DisAuth = ruijie_dbus_server_interface_dbus_proxy_DisAuth;
	iface->SetPassword = ruijie_dbus_server_interface_dbus_proxy_SetPassword;
	iface->get_State = ruijie_dbus_server_interface_dbus_proxy_get_State;
	iface->set_State = ruijie_dbus_server_interface_dbus_proxy_set_State;
	iface->get_Message = ruijie_dbus_server_interface_dbus_proxy_get_Message;
	iface->set_Message = ruijie_dbus_server_interface_dbus_proxy_set_Message;
	iface->get_NetInterface = ruijie_dbus_server_interface_dbus_proxy_get_NetInterface;
	iface->set_NetInterface = ruijie_dbus_server_interface_dbus_proxy_set_NetInterface;
	iface->get_UserName = ruijie_dbus_server_interface_dbus_proxy_get_UserName;
	iface->set_UserName = ruijie_dbus_server_interface_dbus_proxy_set_UserName;
	iface->get_AuthenticationMode = ruijie_dbus_server_interface_dbus_proxy_get_AuthenticationMode;
	iface->set_AuthenticationMode = ruijie_dbus_server_interface_dbus_proxy_set_AuthenticationMode;
	iface->get_EchoInterval = ruijie_dbus_server_interface_dbus_proxy_get_EchoInterval;
	iface->set_EchoInterval = ruijie_dbus_server_interface_dbus_proxy_set_EchoInterval;
	iface->get_IntelligentReconnect = ruijie_dbus_server_interface_dbus_proxy_get_IntelligentReconnect;
	iface->set_IntelligentReconnect = ruijie_dbus_server_interface_dbus_proxy_set_IntelligentReconnect;
	iface->get_AutoConnect = ruijie_dbus_server_interface_dbus_proxy_get_AutoConnect;
	iface->set_AutoConnect = ruijie_dbus_server_interface_dbus_proxy_set_AutoConnect;
	iface->get_FakeVersion = ruijie_dbus_server_interface_dbus_proxy_get_FakeVersion;
	iface->set_FakeVersion = ruijie_dbus_server_interface_dbus_proxy_set_FakeVersion;
	iface->get_DHCPmode = ruijie_dbus_server_interface_dbus_proxy_get_DHCPmode;
	iface->set_DHCPmode = ruijie_dbus_server_interface_dbus_proxy_set_DHCPmode;
	iface->get_PingHost = ruijie_dbus_server_interface_dbus_proxy_get_PingHost;
	iface->set_PingHost = ruijie_dbus_server_interface_dbus_proxy_set_PingHost;
}


static void ruijie_dbus_server_interface_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void ruijie_dbus_server_interface_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}




